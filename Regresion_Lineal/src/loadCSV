const fs = require('fs')
const _ = require('lodash')
const shuffleSeed = require('shuffle-seed')

// FunciÃ³n para quitar las comillas dobles de los nombres de columna
function stripQuotes(columnName) {
    return columnName.replace(/^"(.*)"$/, '$1');
}

function extractCharacter(columnName,regular, characterReplace) {
    return columnName.replace(regular, characterReplace);
}


function extractColumns(data, columnNames){
    const headers = _.first(data);

    const indexes = _.map(columnNames, column => headers.indexOf(column) );
    const extracted = _.map(data, row => _.pullAt(row, indexes) );

    return extracted;
}

module.exports = function loadCSV(
    filename, 
    characterSplit,
    {
        dataColumns     = [],
        labelColumns    = [],
        shuffle         = true,
        splitTest       = 0,
        converters      = {}
    } 
) {
    
    //leemos el fichero csv
    let data = fs.readFileSync(filename, { encoding: 'utf-8' });
    
    //separamos el fichero por filas y por columnas segun el caracter que le pasamos a la funcion
    data = data.split('\n').map(row => row.split(characterSplit));

    //esto nos sirve por si se genera el csv con campos al final vacias value,id,,,, -> value,id
    data = data.map(row => _.dropRightWhile(row, val => val === '') );

    console.log("data1: ", data);

    //quitamos de los titulos '"value"', las ""
    for (let i = 0; i < data[0].length; i++) {
        data[0][i] = stripQuotes(data[0][i]);
    }

    //quitamos los \r de algunas cadenas
    data = data.map( (row, indexRow) => {
        return row.map( (column, indexColumn) =>{
            return extractCharacter(column,/\r/g, '');
        })
    })


    console.log("data2: ", data);

    const headers = _.first(data);

    data = data.map( (row, index) => {

        //en la primera fila estan los nombres
        if(index === 0) return row;

        return row.map( (element, index) => {

            //en caso de tener que convertir algun dato, lo hacemos segun nos indican los converters
            if(converters[headers[index]]){
                const converted = converters[headers[index]](element);
                return _.isNaN(converted) ? element : converted
            }

            const result = parseFloat(element);
            return _.isNaN(result) ? element : result; 
        });

    });

    console.log("data3: ", data);

    //separamos en distintos arrays los labels y features
    let labels = extractColumns(data, labelColumns);
    data = extractColumns(data, dataColumns);

    console.log("data4: ", data);
    console.log("label: ", labels);

    //quitamos el primer elemento de cada array ya que estan los nombres de las columnas y no lo queremos
    labels.shift();
    data.shift();

    

    //en caso de indicar de mezclar el array, lo mezclamos
    if( shuffle ){
        data = shuffleSeed.shuffle(data, 'phrase' ); //ambos array se tienen que mezclar con el mismo string, por eos ponemos phrase en ambos
        labels = shuffleSeed.shuffle(labels, 'phrase' );
    }


    if( splitTest ){
        const trainSize = _.isNumber( splitTest ) ? splitTest : Math.floor(data.length / 2);

        return {
            features:       data.slice(0,trainSize),
            labels:         labels.slice(0,trainSize),
            testFeatures:   data.slice(trainSize),
            testLabels:     labels.slice(trainSize),
        }

    }
    else{
        return { features: data, labels };
    }


}
    
